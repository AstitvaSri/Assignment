# Search Algorithms 

## Formal Modelling 

## Search Tree 
	At each stage check if we have reached the goal, if not we take new actions and try to reach a new state.
	New state => frontier states 
	Old State => explored state


## Graph Search vs Tree Search 	
	Graph remembers the last states. 
	It might reach to an explored state, hence it might cause a redundant path. 

	Tree doesn't remember the last path 

Using Hash table for storing data

Queue 
Stack 

Node in tree ? 
	State
	Parent => To not forgeting the path to reach here
	Action => which action lead me here
	Path-Cost => Cost from intital node to child 
					= Cost for parent + step cost from parent to child

## Measuring Performance 
	- Completeness 
	- Opimality -> best solution 
	- Time Complexiy -> time takes for each search 
	- Space Complexity -> Memory Space 

## Problem Size 
	- b, branching factor
	- d, shallowest or the earliest goal node
	- m, Maximum length of any pasth in state space

	- time => how many nodes generated by the algorithm
	- space => number of nodes saved in the memory						 

## Uninformed Search Strategies
	- No information given for the most suitable action to be choosen

## Heuristics Search 
	- Priorotizes to the search, 
	- Needs additional information 


## BFS 
	- Expland the shallowest node
	- deepest node at the last element  
	- Complete, optimal 
	- Time complexty  => O(b^d)
	- Space => O(b^d) // too big 
	 	BFS on a binary tree  

## Uniform Cost Search 
	Only check at the time of expansion not generation of nodes. 

	Complexity = O(b^(1+lb(C*/e)))
					lb = lowebound 
					e  = shortest path cost,edge cost 
					e = 1 for bfs 
 


